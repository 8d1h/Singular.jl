<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrices · Singular.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Singular.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Getting Started</a></li><li><span class="toctext">Coefficient rings</span><ul><li><a class="toctext" href="../integer/">Integers</a></li><li><a class="toctext" href="../rational/">Rational field</a></li><li><a class="toctext" href="../modn/">Integers mod n</a></li><li><a class="toctext" href="../modp/">Integers mod p</a></li><li><a class="toctext" href="../transExt/">Function fields</a></li><li><a class="toctext" href="../GF/">Finite fields</a></li><li><a class="toctext" href="../nemo/">Nemo rings and fields</a></li></ul></li><li><a class="toctext" href="../polynomial/">Multivariate polynomials</a></li><li><a class="toctext" href="../ideal/">Ideals</a></li><li><span class="toctext">Modules</span><ul><li><a class="toctext" href="../module/">Finitely generated modules</a></li><li><a class="toctext" href="../vector/">Free modules and vectors</a></li></ul></li><li><a class="toctext" href="../alghom/">Algebra Homomorphisms</a></li><li><a class="toctext" href="../resolution/">Resolutions</a></li><li class="current"><a class="toctext" href>Matrices</a><ul class="internal"><li><a class="toctext" href="#Matrix-functionality-1">Matrix functionality</a></li><li><a class="toctext" href="#Basic-constructors-1">Basic constructors</a></li><li><a class="toctext" href="#Basic-manipulation-1">Basic manipulation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Matrices</a></li></ul><a class="edit-page" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/matrix.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Matrices</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Matrices-1" href="#Matrices-1">Matrices</a></h1><p>Singular internally allows for matrices over polynomial rings to be created extremely efficiently from ideals and modules (often without copying data). This allows for introspection of modules and operations that can be expressed in terms of matrices (e.g. composition of <span>$R$</span>-module homomorphisms) to be computed, at a low level.</p><p>The default matrix type in Singular.jl is the <code>smatrix</code> type.</p><p>Matrix objects have a parent object which represents the space of matrices they belong to, the data for which is given by the polynomial ring <span>$R$</span> over which the matrices are defined, and the number of rows and columns of the matrices in the space.</p><p>The types of matrices and associated parent objects are given in the following table according to the library provding them.</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Singular</td><td style="text-align: right"><code>smatrix{T}</code></td><td style="text-align: right"><code>Singular.MatrixSpace{T}</code></td></tr></table><p>These types are parameterised by the type of elements in the polynomial ring <span>$R$</span> over which the matrices are defined.</p><p>All matrix types belong directly to the abstract type <code>SetElem</code> and all the matrix space parent object types belong to the abstract type <code>Set</code>.</p><h2><a class="nav-anchor" id="Matrix-functionality-1" href="#Matrix-functionality-1">Matrix functionality</a></h2><p>Singular.jl matrices implement standard operations one would expect. These include:</p><ul><li>Operations common to all AbstractAlgebra objects, such as <code>parent</code>, <code>base_ring</code>, <code>elem_type</code>, <code>parent_type</code>, <code>parent</code>, <code>deepcopy</code>, etc.</li></ul><p>The following parts of the Matrix interface from AbstractAlgebra are also implemented:</p><ul><li>arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code></li><li>comparison: <code>==</code></li></ul><h2><a class="nav-anchor" id="Basic-constructors-1" href="#Basic-constructors-1">Basic constructors</a></h2><p>Using Singular.jl, the user has two basic constructors for matrices.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.identity_matrix-Tuple{PolyRing,Int64}" href="#AbstractAlgebra.Generic.identity_matrix-Tuple{PolyRing,Int64}"><code>AbstractAlgebra.Generic.identity_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><p>identity_matrix(R::PolyRing, n::Int) Returns the <span>$n \times n$</span> identity matrix over <span>$R.$</span></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.zero_matrix-Tuple{PolyRing,Int64,Int64}" href="#AbstractAlgebra.Generic.zero_matrix-Tuple{PolyRing,Int64,Int64}"><code>AbstractAlgebra.Generic.zero_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><p>zero_matrix(R::PolyRing, r::Int, c::Int) Returns the <span>$r \times c$</span> zero matrix over <span>$R.$</span></p></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, u, v, w) = Singular.PolynomialRing(Singular.QQ, [&quot;x&quot;, &quot;y&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;])

identity_matrix(R, 4)

zero_matrix(R, 3, 8)</code></pre><h2><a class="nav-anchor" id="Basic-manipulation-1" href="#Basic-manipulation-1">Basic manipulation</a></h2><p>The following functions are provided to manipulate matrices and to set and retrieve entries other basic data associated with the matrices.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.nrows-Tuple{smatrix}" href="#AbstractAlgebra.Generic.nrows-Tuple{smatrix}"><code>AbstractAlgebra.Generic.nrows</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">nrows(M::smatrix)</code></pre><p>Return the number of rows of <span>$M$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.ncols-Tuple{smatrix}" href="#AbstractAlgebra.Generic.ncols-Tuple{smatrix}"><code>AbstractAlgebra.Generic.ncols</code></a> — <span class="docstring-category">Method</span>.</div><div><p>nrows(M::smatrix) Return the number of colums of <span>$M$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{smatrix{T},Int64,Int64}} where T&lt;:AbstractAlgebra.RingElem" href="#Base.getindex-Union{Tuple{T}, Tuple{smatrix{T},Int64,Int64}} where T&lt;:AbstractAlgebra.RingElem"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><p>getindex(M::smatrix{T}, i::Int, j::Int) where T &lt;: AbstractAlgebra.RingElem Given a matrix <span>$M = (m_{ij})_{i, j}$</span>, return the entry <span>$m_{ij}$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Tuple{smatrix,spoly,Int64,Int64}" href="#Base.setindex!-Tuple{smatrix,spoly,Int64,Int64}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>setindex!(M::smatrix, p::spoly i::Int, j::Int) Given a matrix <span>$M = (m_{ij})_{i, j}$</span>, set the entry <span>$m_{ij}$</span> to the value <span>$p$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.transpose-Union{Tuple{smatrix{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem" href="#Base.transpose-Union{Tuple{smatrix{T}}, Tuple{T}} where T&lt;:AbstractAlgebra.RingElem"><code>Base.transpose</code></a> — <span class="docstring-category">Method</span>.</div><div><p>transpose(M::smatrix{T}) where T &lt;: AbstractAlgebra.RingElem Given a matrix <span>$M=(m_{ij})_{i, j}$</span>, return the matrix <span>$M^T=(m_{ji})_{j, i}$</span>.</p></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>iszero(M::smatrix)</code>. Check Documenter&#39;s build log for details.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y, u, v, w) = Singular.PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;])

M = identity_matrix(R, 4)

nrows(M)

ncols(M)

iszero(M)

M[3, 4] = x*y + 5*u*w

N = transpose(M)

N[4, 3]</code></pre><footer><hr/><a class="previous" href="../resolution/"><span class="direction">Previous</span><span class="title">Resolutions</span></a></footer></article></body></html>
