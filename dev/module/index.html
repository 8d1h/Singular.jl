<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finitely generated modules · Singular.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Singular.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Getting Started</a></li><li><span class="toctext">Coefficient rings</span><ul><li><a class="toctext" href="../integer/">Integers</a></li><li><a class="toctext" href="../rational/">Rational field</a></li><li><a class="toctext" href="../modn/">Integers mod n</a></li><li><a class="toctext" href="../modp/">Integers mod p</a></li><li><a class="toctext" href="../transExt/">Function fields</a></li><li><a class="toctext" href="../GF/">Finite fields</a></li><li><a class="toctext" href="../nemo/">Nemo rings and fields</a></li></ul></li><li><a class="toctext" href="../polynomial/">Multivariate polynomials</a></li><li><a class="toctext" href="../ideal/">Ideals</a></li><li><span class="toctext">Modules</span><ul><li class="current"><a class="toctext" href>Finitely generated modules</a><ul class="internal"><li><a class="toctext" href="#Module-functionality-1">Module functionality</a></li></ul></li><li><a class="toctext" href="../vector/">Free modules and vectors</a></li></ul></li><li><a class="toctext" href="../alghom/">Algebra Homomorphisms</a></li><li><a class="toctext" href="../resolution/">Resolutions</a></li><li><a class="toctext" href="../matrix/">Matrices</a></li></ul></nav><article id="docs"><header><nav><ul><li>Modules</li><li><a href>Finitely generated modules</a></li></ul><a class="edit-page" href="https://github.com/oscar-system/Singular.jl/blob/master/docs/src/module.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Finitely generated modules</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Finitely-generated-modules-1" href="#Finitely-generated-modules-1">Finitely generated modules</a></h1><p>Singular.jl allows the creation of submodules of a free module over a Singular polynomial ring, given by a finite generating set. These are internally stored as a list of elements of a free module over a polynomial ring <span>$R$</span>. This list of generators can also  have the property of being a Groebner basis.</p><p>The default finitely generated module type in Singular.jl is the Singular <code>smodule</code> type.</p><p>Module objects have a parent object which represents the class of <span>$R$</span>-modules they belong to, the data for which is given by the polynomial ring <span>$R$</span> over which the modules are defined.</p><p>The types of modules and associated parent objects are given in the following table according to the library provding them.</p><table><tr><th style="text-align: right">Library</th><th style="text-align: right">Element type</th><th style="text-align: right">Parent type</th></tr><tr><td style="text-align: right">Singular</td><td style="text-align: right"><code>smodule{T}</code></td><td style="text-align: right"><code>Singular.ModuleClass{T}</code></td></tr></table><p>These types are parameterised by the type of elements in the polynomial ring <span>$R$</span>.</p><p>All module types belong directly to the abstract type <code>Module{T}</code> and all the module class parent object types belong to the abstract type <code>Set</code>.</p><h2><a class="nav-anchor" id="Module-functionality-1" href="#Module-functionality-1">Module functionality</a></h2><p>Singular.jl modules implement standard operations one would expect on modules. These include:</p><ul><li>Operations common to all AbstractAlgebra objects, such as <code>parent</code>, <code>base_ring</code>, <code>elem_type</code>, <code>parent_type</code>, <code>parent</code>, <code>deepcopy</code>, etc.</li></ul><p>Below, we describe all of the functionality for Singular.jl modules that is not included in this list of basic operations.</p><h3><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h3><p>Given a Singular polynomial ring <span>$R$</span>, the following constructors are available for creating modules.</p><pre><code class="language-julia">Module{T &lt;: Nemo.RingElem}(R::PolyRing{T}, vecs::svector{spoly{T}}...)</code></pre><p>Construct the module over the polynomial ring <span>$R$</span> whose generators are given  by the given parameter list of vectors (of length <span>$n$</span>), each component of which is a polynomial. These vectors represent elements of the free module <span>$R^n$</span>.</p><p>Note that <code>Module</code> must be prepended with the package name <code>Singular</code> to disambiguate from <code>Base.Module</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^2 + 1, 2x + 3y, x)

M = Singular.Module(R, v1, v2)</code></pre><h3><a class="nav-anchor" id="Basic-manipulation-1" href="#Basic-manipulation-1">Basic manipulation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AbstractAlgebra.Generic.ngens-Tuple{smodule}" href="#AbstractAlgebra.Generic.ngens-Tuple{smodule}"><code>AbstractAlgebra.Generic.ngens</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">ngens(I::smodule)</code></pre><p>Return the number of generators in the current representation of the module (as a list of vectors).</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.rank-Tuple{smodule}" href="#LinearAlgebra.rank-Tuple{smodule}"><code>LinearAlgebra.rank</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">rank(I::smodule)</code></pre><p>Return the rank <span>$n$</span> of the ambient space <span>$R^n$</span> of which this module is a submodule.</p></div></section><p>Singular.jl overloads the <code>setindex!</code> and <code>getindex</code> functions so that one can access the generators of a module using array notation. Each entry is a vector in <span>$R^n$</span>.</p><pre><code class="language-julia">M[n::Int]</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.iszero-Tuple{smodule}" href="#Base.iszero-Tuple{smodule}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">iszero(p::smodule)</code></pre><p>Return <code>true</code> if this is algebraically the zero module.</p></div></section><p><strong>Examples</strong></p><pre><code class="language-none">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^2 + 1, 2x + 3y, x)

M = Singular.Module(R, v1, v2)

iszero(M) == false
M[1] == v1
n = rank(M)
d = ngens(M)</code></pre><h3><a class="nav-anchor" id="Standard-basis-1" href="#Standard-basis-1">Standard basis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.std-Tuple{smodule}" href="#Statistics.std-Tuple{smodule}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">std(I::smodule; complete_reduction::Bool=false)</code></pre><p>Compute the Groebner basis of the module <span>$I$</span>. If <code>complete_reduction</code> is set to <code>true</code>, the result is unique, up to permutation of the generators and multiplication by constants. If not, only the leading terms are unique (up to permutation of the generators and multiplication by constants, of course). Presently the polynomial ring used must be over a field or over the Singular integers.</p></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^2 + 1, 2x + 3y, x)
v3 = x*v1 + y*v2 + vector(R, x, y + 1, y^2)

M = Singular.Module(R, v1, v2, v3)

G = std(M; complete_reduction=true)</code></pre><h3><a class="nav-anchor" id="Syzygies-1" href="#Syzygies-1">Syzygies</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.syz-Tuple{smodule}" href="#Singular.syz-Tuple{smodule}"><code>Singular.syz</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">syz(M::smodule)</code></pre><p>Compute the module of syzygies of the given module. This will be given as a set of generators in an ambient space <span>$R^n$</span>, where <span>$n$</span> is the number of generators in <span>$M$</span>.</p></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, (x + 1)*y, (x*y + 1)*y, y)
v2 = vector(R, (x + 1)*x, (x*y + 1)*x, x)

M = Singular.Module(R, v1, v2)

Z = syz(M)</code></pre><h3><a class="nav-anchor" id="Free-resolutions-1" href="#Free-resolutions-1">Free resolutions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.sres-Union{Tuple{T}, Tuple{smodule{T},Int64}} where T&lt;:AbstractAlgebra.RingElem" href="#Singular.sres-Union{Tuple{T}, Tuple{smodule{T},Int64}} where T&lt;:AbstractAlgebra.RingElem"><code>Singular.sres</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">sres{T &lt;: Nemo.RingElem}(I::smodule{T}, max_length::Int)</code></pre><p>Compute a free resolution of the given module <span>$I$</span> of length up to the given maximum length. If <code>max_length</code> is set to zero, a full length free resolution is computed. Each element of the resolution is itself a module.</p></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^2 + 1, 2x + 3y, x)

M = std(Singular.Module(R, v1, v2))

F = sres(M, 0)

M1 = Singular.Matrix(M)
M2 = Singular.Matrix(F[2])

# test we have a complex
iszero(M1*M2)</code></pre><h3><a class="nav-anchor" id="Jet-of-module-1" href="#Jet-of-module-1">Jet of module</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.jet-Tuple{smodule,Int64}" href="#Singular.jet-Tuple{smodule,Int64}"><code>Singular.jet</code></a> — <span class="docstring-category">Method</span>.</div><div><p>jet(M::smodule, n::Int) Given a module <span>$M$</span> this function truncates the generators of <span>$M$</span> up to degree <span>$n$</span>.</p></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;])

v1 = vector(R, x + 1, x*y + 1, y)
v2 = vector(R, x^5 + 1, 2x^3 + 3y^2, x^2)

M = Singular.Module(R, v1, v2)
N = jet(M,3)</code></pre><h3><a class="nav-anchor" id="Operations-over-local-rings-1" href="#Operations-over-local-rings-1">Operations over local rings</a></h3><p>If the base ring <code>R</code> is a local ring, a minimal generating set can be computed using the following function</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Singular.minimal_generating_set-Tuple{smodule}" href="#Singular.minimal_generating_set-Tuple{smodule}"><code>Singular.minimal_generating_set</code></a> — <span class="docstring-category">Method</span>.</div><div><p>minimal<em>generating</em>set(M::smodule) Given a module <span>$M$</span> in ring <span>$R$</span> with local ordering, this returns an array containing the minimal generators of <span>$M$</span>.</p></div></section><p><strong>Examples</strong></p><pre><code class="language-julia">R, (x, y) = PolynomialRing(QQ, [&quot;x&quot;, &quot;y&quot;]; ordering=:negdegrevlex)

has_local_ordering(R) == true

v1 = vector(R, x, y^2)
v2 = vector(R, y - x, y - y^2)
v3 = v1 + v2

M = Singular.Module(R, v1, v2, v3)
   
min = minimal_generating_set(M)</code></pre><footer><hr/><a class="previous" href="../ideal/"><span class="direction">Previous</span><span class="title">Ideals</span></a><a class="next" href="../vector/"><span class="direction">Next</span><span class="title">Free modules and vectors</span></a></footer></article></body></html>
